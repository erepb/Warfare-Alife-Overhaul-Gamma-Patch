--[[

=======================================================================================
	Original creator: Werejew
	Edit log:
	2020/11/07 - Vintar - Resurgence chance added to resurgence calculation
	2021/02/19 - Vintar - stronger resurgence attempts, now uses fetch_smart_distance(), debug messages
	2021/03/27 - Vintar - loners exempt from random patrol targeting. Random patrols no longer spawn too close to actor.
	2021/11/22 - Vintar - slight change to resurgence base count

	This file handles faction-level warfare stuff like random patrols, resurgences, etc.
=======================================================================================

--]]

local enable_debug = false

printd = warfare.printd
printdbg = warfare.printdbg

factions_p = {}
factions = {
    "stalker",
    "bandit",
    "csky",
    "army",
    "freedom",
    "dolg",
    "ecolog",
    "killer",
    "monolith",
    "greh",
    "renegade",
    "isg",
    --"monster",
    "zombied",
}

all_factions = {
    "stalker",
    "bandit",
    "csky",
    "army",
    "freedom",
    "dolg",
    "ecolog",
    "killer",
    "monolith",
    "greh",
    "renegade",
    "isg",
    "monster",
    "zombied",
}

-- Mapping of main bases to their original factions
local faction_main_bases = {
    ["dolg"] = {"bar_dolg_general", "bar_dolg_bunker", "bar_zastava", "bar_zastava_2"},
    ["freedom"] = {"mil_smart_terrain_7_7", "mil_smart_terrain_7_8", "mil_smart_terrain_7_10", "mil_smart_terrain_7_12", "jup_a6"},
    ["army"] = {"agr_smart_terrain_1_6", "agr_smart_terrain_1_6_near_1", "agr_smart_terrain_1_6_near_2", "esc_smart_terrain_3_16", "val_smart_terrain_1_2"},
    ["bandit"] = {"val_smart_terrain_7_4", "val_smart_terrain_7_5", "val_smart_terrain_8_6"},
    ["killer"] = {"cit_killers"},
    ["monolith"] = {"pri_monolith"},
    ["ecolog"] = {"yan_smart_terrain_6_4", "jup_b41"},
    ["csky"] = {"mar_smart_terrain_base"},
    ["stalker"] = {"esc_smart_terrain_2_12", "zat_stalker_base_smart"},
    ["renegade"] = {"mar_smart_terrain_3_3"},
    ["greh"] = {"red_smart_terrain_4_2"},
    ["isg"] = {"ds2_domik_st", "agr_smart_terrain_1_6", "val_smart_terrain_1_2", "jup_a10_smart_terrain", "zat_b103_merc_smart", "pri_b306"},
}

faction_information = {}
faction_timers = {}

for i = 1, #factions do
    factions_p[factions[i]] = true
end

--[[

	faction_information[faction] = {
		base_count,
		resource_count,
		total_power,
		defense_squads, -- current_action == 1 and (target.props.base > 0 or target.props.resource > 0)
		offense_squads, -- current_action == 0 and (target.props.base > 0 or target.props.resource > 0)
		patrol_squads,	-- current_action == 0 and (target.props.base == 0 and target.props.resource == 0)
		relations = {
			[faction] = value
		},
	}

]]

-- Advance faction-level spawn timer timestamps forward by the given number of game seconds.
-- Called at the night-to-day transition to preserve timer progress across night.
function advance_spawn_timers(seconds)
    for _, faction in pairs(factions) do
        local info = faction_information[faction]
        if info and info.last_random_patrol then
            info.last_random_patrol = warfare_utils.add_time(info.last_random_patrol, seconds)
        end
    end
end

function update()
    for i, faction in pairs(factions) do
        if faction ~= "monster" then
            update_faction(faction)
        end
    end
end

function update_faction(faction)
    if (not faction or faction == "none") then
        return
    end

    if not (faction_information[faction]) then
        local min_resurgence_wait_time = warfare_options.options.factions[faction].min_resurgence_wait_time
        local max_resurgence_wait_time = warfare_options.options.factions[faction].max_resurgence_wait_time
        local faction_resurgence_chance = warfare_options.options.factions[faction].resurgence_chance

        local max_random_patrols = warfare_options.options.factions[faction].max_random_patrols
        local min_random_patrol_time = warfare_options.options.factions[faction].min_random_patrol_time
        local max_random_patrol_time = warfare_options.options.factions[faction].max_random_patrol_time

        local next_resurgence_attempt = math.random(min_resurgence_wait_time, max_resurgence_wait_time)
        local next_random_patrol = math.random(min_random_patrol_time, max_random_patrol_time) * (warfare_options.options.spawn_speed_multiplier or 1)

        faction_information[faction] = {}
        faction_information[faction].base_count = 0
        faction_information[faction].resource_count = 0
        faction_information[faction].total_power = 0
        faction_information[faction].inactive_squads = 0
        faction_information[faction].active_squads = 0
        faction_information[faction].faction_respawn = 0
        faction_information[faction].patrol_respawn = 0
        faction_information[faction].patrol_squads = 0
        faction_information[faction].invasion_size = 0
        faction_information[faction].patrol_pop_factor = 0
        faction_information[faction].last_resurgence_attempt = warfare.get_time()
        faction_information[faction].next_resurgence_attempt = next_resurgence_attempt
        faction_information[faction].next_random_patrol = 0
        faction_information[faction].last_random_patrol = warfare.get_time()
    end

    if (not faction_information[faction].timer or warfare.get_time_ref():diffSec(faction_information[faction].timer) >= (faction_information[faction].next_update * 6)) then
        printd(0, faction or "nil faction")

        local min_resurgence_wait_time = warfare_options.options.factions[faction].min_resurgence_wait_time
        local max_resurgence_wait_time = warfare_options.options.factions[faction].max_resurgence_wait_time
        local faction_resurgence_chance = warfare_options.options.factions[faction].resurgence_chance

        local max_random_patrols = warfare_options.options.factions[faction].max_random_patrols
        local min_random_patrol_time = warfare_options.options.factions[faction].min_random_patrol_time
        local max_random_patrol_time = warfare_options.options.factions[faction].max_random_patrol_time

        local last_resurgence_attempt = faction_information[faction].last_resurgence_attempt or warfare.get_time()
        local next_resurgence_attempt = faction_information[faction].next_resurgence_attempt or math.random(min_resurgence_wait_time, max_resurgence_wait_time)
        local last_random_patrol = faction_information[faction].last_random_patrol or warfare.get_time()
        local next_random_patrol = faction_information[faction].next_random_patrol or math.random(min_random_patrol_time, max_random_patrol_time) * (warfare_options.options.spawn_speed_multiplier or 1)

        faction_information[faction] = {}
        if not faction_information[faction].timer then
            faction_information[faction].timer = warfare.get_time()
        else
            faction_information[faction].timer = warfare_utils.add_time(faction_information[faction].timer, faction_information[faction].next_update*6)
        end

        faction_information[faction].next_update = math.random(1, 5)
        faction_information[faction].base_count = 0
        faction_information[faction].resource_count = 0
        faction_information[faction].total_power = 0
        faction_information[faction].inactive_squads = 0
        faction_information[faction].active_squads = 0
        faction_information[faction].faction_respawn = 0
        faction_information[faction].patrol_respawn = 0
        faction_information[faction].patrol_squads = 0
        faction_information[faction].invasion_size = 0
        faction_information[faction].patrol_pop_factor = 0
        faction_information[faction].last_resurgence_attempt = last_resurgence_attempt
        faction_information[faction].next_resurgence_attempt = next_resurgence_attempt
        faction_information[faction].last_random_patrol = last_random_patrol
        faction_information[faction].next_random_patrol = next_random_patrol

        for i, lvl in pairs(level_targets.active_levels) do
            local info = warfare_levels.level_information[lvl]

            if (info.faction_stats and info.faction_stats[faction]) then
                local num_active = sim_offline_combat.get_num_squads_on_level(lvl, faction, true)
                local num_inactive = sim_offline_combat.get_num_squads_on_level(lvl, faction, false)

                faction_information[faction].base_count = faction_information[faction].base_count + info.faction_stats[faction].base_count
                faction_information[faction].resource_count = faction_information[faction].resource_count + info.faction_stats[faction].resource_count
                faction_information[faction].total_power = faction_information[faction].total_power + info.faction_stats[faction].total_power
                faction_information[faction].active_squads = faction_information[faction].active_squads + num_active
                faction_information[faction].inactive_squads = faction_information[faction].inactive_squads + num_inactive
            end
        end

        local ff = warfare_options.options.factions[faction]

        if not (ff) then
            return
        end

        local base_count = faction_information[faction].base_count or 0
        local resource_count = faction_information[faction].resource_count or 0

        if (game_relations.is_factions_enemies(faction, warfare.actor_faction)) then
            base_count = base_count + warfare_options.options.enemy_base_boost
            resource_count = resource_count + warfare_options.options.enemy_resource_boost
        end

        base_count = base_count + (ff and ff.base_count_modifier or 0)
        resource_count = resource_count + (ff and ff.resource_count_modifier or 0)

        faction_information[faction].base_count = base_count
        faction_information[faction].resource_count = resource_count

        local spawn_mult = warfare_options.options.spawn_speed_multiplier or 1
        local respawn = warfare.lerp(ff.max_faction_respawn, ff.min_faction_respawn, clamp(resource_count / warfare.resource_count, 0, 1)) * spawn_mult
        local patrol_respawn = warfare.lerp(ff.max_patrol_time, ff.min_patrol_time, clamp(resource_count / warfare.resource_count, 0, 1)) * spawn_mult
        local invasion_size = warfare.lerp(ff.min_invasion_size, ff.max_invasion_size, clamp(base_count / warfare.base_count, 0, 1))
        local patrol_pop_factor = warfare.lerp(ff.min_patrol_squads, ff.max_patrol_squads, clamp(base_count / warfare.base_count, 0, 1))

        for faction, tbl in pairs(warfare.registered_squads) do
            for ID, target in pairs(tbl) do
                local obj = alife_object(ID)

                if (obj) then
                    if not (obj.clsid and obj:clsid() == clsid.online_offline_group_s and obj:get_squad_community() == faction) then
                        warfare.registered_squads[faction][ID] = nil
                    end
                else
                    warfare.registered_squads[faction][ID] = nil
                end
            end
        end

        faction_information[faction].faction_respawn = respawn
        faction_information[faction].patrol_respawn = patrol_respawn
        faction_information[faction].patrol_squads = patrol_squads
        faction_information[faction].invasion_size = invasion_size
        faction_information[faction].patrol_pop_factor = patrol_pop_factor

        local mod = (ff and ff.base_count_modifier or 0)

        if (game_relations.is_factions_enemies(faction, warfare.actor_faction)) then
            mod = mod + warfare_options.options.enemy_base_boost
        end

        if (warfare_options.options.factions[faction].random_patrols) and not warfare.is_spawn_blocked() then
            if (warfare.get_time_ref():diffSec(faction_information[faction].last_random_patrol) > faction_information[faction].next_random_patrol * 6) then
                faction_information[faction].last_random_patrol = warfare_utils.add_time(faction_information[faction].last_random_patrol, faction_information[faction].next_random_patrol*6)
                faction_information[faction].next_random_patrol = math.random(min_random_patrol_time, max_random_patrol_time) * (warfare_options.options.spawn_speed_multiplier or 1)

                local start_id = smart_terrain_warfare.find_random_patrol_target(nil, faction)
                local start = start_id and alife_object(start_id)
                local target_id

                -- loners/ecolog don't get sent off randomly, they get sent according to their respective loner/ecolog process functions
                if (faction == "stalker") or (faction == "ecolog") then
                    target_id = start_id
                else
                    target_id = smart_terrain_warfare.find_random_patrol_target(start, faction)
                end

                local count = 0
                for squad_id, squad_faction in pairs(smart_terrain_warfare.random_patrols) do
                    if (squad_faction and squad_faction == faction) then
                        count = count + 1
                    end
                end

                if (start and target_id and (count < max_random_patrols)) then
                    local spawn_random_patrol = true

                    -- don't spawn random patrols too close to player
                    if (start.is_on_actor_level) then
                        local actor_dist = start.position:distance_to(db.actor:position())
                        if (actor_dist < 50) then
                            spawn_random_patrol = false
                            faction_information[faction].next_random_patrol = math.random(30, 120)        -- if random patrol fails to spawn, check back sooner to try elsewhere
                        end
                    end

                    if spawn_random_patrol then
                        local current_level = start.level_id
                        local section = faction_expansions.get_spawn_section(faction, faction_information[faction].resource_count, current_level)
                        local squad = utils_obj.create_squad(section, start:name())
                        printdbg("WARFARE DEBUG: spawning random patrol squad faction: %s, resources: %s", faction, faction_information[faction].resource_count)

                        smart_terrain_warfare.random_patrols[squad.id] = faction
                        sim_squad_warfare.set_target(squad, target_id)
                    end
                end
            end
        end

        -- Emergency resurrection when faction has 0 bases
        if not warfare.is_spawn_blocked() and (warfare_options.options.factions[faction].participate_in_warfare and (faction_information[faction].base_count + mod) < 1) then
            if (warfare.get_time_ref():diffSec(faction_information[faction].last_resurgence_attempt) > faction_information[faction].next_resurgence_attempt * 6) then
                faction_information[faction].last_resurgence_attempt = warfare.get_time()
                faction_information[faction].next_resurgence_attempt = math.random(min_resurgence_wait_time, max_resurgence_wait_time)

                -- Choose between new and old resurgence logic
                if warfare_options.options.use_new_resurgence_logic then
                    -- Emergency spawn: Create powerful squad for extinct factions
                    local emergency_attempted = emergency_resurrection_spawn(faction)
                    if emergency_attempted then
                        if (enable_debug) then
                            printf("Emergency resurrection activated for extinct faction: %s", faction)
                        end
                    end
                else
                    -- Original resurgence logic with chance to skip
                    if math.random(0, 99) < faction_resurgence_chance then
                        local levels = warfare.hash_table_to_array(level_targets.active_levels)
                        warfare.shuffleTable(levels)

                        local attempted = false
                        for _, v in pairs(levels) do
                            local chosen = v.key
                            local info = warfare_levels.level_information[chosen]

                            if (info) then
                                local smarts = info.smarts
                                local targets = {}
                                local spawns = {}

                                for v, smart_id in pairs(smarts) do
                                    local smart = alife_object(smart_id)

                                    if (smart) then
                                        if (smart.props and smart.props.base > 0) then
                                            if (smart.owning_faction == "none" or game_relations.is_factions_enemies(smart.owning_faction, faction)) then
                                                targets[#targets + 1] = smart
                                            end
                                        elseif (smart.props and smart.props.territory > 0 and (smart.props.resource == nil or smart.props.resource <= 0)) then
                                            spawns[#spawns + 1] = smart
                                        end
                                    end
                                end

                                if (#spawns > 0 and #targets > 0) then
                                    local target = targets[math.random(#targets)]

                                    -- stronger resurgence attempts
                                    local target_pop = 2 * target.max_population

                                    local nearest_smart = nil
                                    local nearest_dist = nil

                                    attempted = true

                                    if (enable_debug) then
                                        printf("Resurgence of %s is underway, targeting %s with %s squads", faction, target:name(), target_pop)
                                    end

                                    for _, ter in pairs(spawns) do
                                        local d = smart_terrain_warfare.fetch_smart_distance(target, ter)

                                        if (nearest_dist == nil or d < nearest_dist) then
                                            nearest_smart = ter
                                            nearest_dist = d
                                        end
                                    end

                                    for j = 0, target_pop do
                                        local current_level = nearest_smart.level_id
                                    local section = faction_expansions.get_spawn_section(faction, faction_information[faction].resource_count, current_level)
                                        local squad = utils_obj.create_squad(section, nearest_smart:name())
                                        sim_squad_warfare.set_target(squad, target.id)
                                    end
                                end
                            end

                            if (attempted) then
                                break
                            end
                        end
                    end
                end
            end
        end

        printd(9, "true end")
    end
end

-- Emergency resurrection function for extinct factions
function emergency_resurrection_spawn(faction)
    printf("warfare debug: emergency_resurrection_spawn for %s", faction)
    if not faction or faction == "none" then
        return false
    end

    local levels = warfare.hash_table_to_array(level_targets.active_levels)
    warfare.shuffleTable(levels)

    local all_targets = {}
    local priority_targets = {} -- Former faction bases get priority

    -- Step 1: Collect all possible targets across all levels
    for _,v in pairs(levels) do
        local chosen = v.key
        local info = warfare_levels.level_information[chosen]

        if (info) then
            local smarts = info.smarts

            for v,smart_id in pairs(smarts) do
                local smart = alife_object(smart_id)

                if (smart) then
                    if (smart.props and smart.props.base > 0) then
                        if (smart.owning_faction == "none" or game_relations.is_factions_enemies(smart.owning_faction, faction)) then
                            if enable_debug then printf("Emergency resurrection: Found target %s owned by %s", smart:name(), smart.owning_faction) end
                            if is_faction_main_base(smart:name(), faction) then
                                if enable_debug then printf("Emergency resurrection: %s is a priority (former main) base of %s", smart:name(), faction) end
                                priority_targets[#priority_targets+1] = smart
                            elseif not is_smart_main_base(smart:name()) then
                                all_targets[#all_targets+1] = smart
                            end
                        end
                    end
                end
            end
        end
    end

    -- Step 2: Select the best target
    local best_target = nil

    if #priority_targets > 0 then
        -- Pick a random former faction base as target
        best_target = priority_targets[math.random(#priority_targets)]
        if enable_debug then printf("Emergency resurrection: Selected priority target %s for %s", best_target:name(), faction) end
    elseif #all_targets > 0 then
        if enable_debug then printf("Emergency resurrection: No priority targets, selecting from %s regular targets for %s", #all_targets, faction) end
        -- Find closest target to any of the faction's known main bases
        local main_base_smarts = {}
        local main_base_names = faction_main_bases[faction]
        if main_base_names then
            for _, base_name in pairs(main_base_names) do
                local smart = alife():story_object(base_name)
                if smart then main_base_smarts[#main_base_smarts+1] = smart end
            end
        end

        if #main_base_smarts > 0 then
            local best_dist = nil
            for _,target in pairs(all_targets) do
                for _,main_base in pairs(main_base_smarts) do
                    local distance = smart_terrain_warfare.fetch_smart_distance(main_base, target)
                    if distance > 10000 and (best_dist == nil or distance < best_dist) then
                        best_dist = distance
                        best_target = target
                    end
                end
            end
            if enable_debug and best_target then
                printf("Emergency resurrection: Selected target %s closest to %s main base (dist: %s)", best_target:name(), faction, best_dist)
            end
        end

        -- Last resort: pick a random target if main base proximity didn't yield one
        if not best_target then
            best_target = all_targets[math.random(#all_targets)]
            if enable_debug then printf("Emergency resurrection: Random fallback target %s for %s", best_target:name(), faction) end
        end
    end

    if not best_target then
        if enable_debug then printf("Emergency resurrection: No valid target found for %s", faction) end
        return false
    end

    -- Step 3: Find the closest valid spawn point to the selected target
    -- Valid spawn: neutral/friendly territory/resource, OR any lair
    local best_spawn = nil
    local best_spawn_dist = nil

    for _,v in pairs(levels) do
        local chosen = v.key
        local info = warfare_levels.level_information[chosen]

        if (info) then
            local smarts = info.smarts

            for v,smart_id in pairs(smarts) do
                local smart = alife_object(smart_id)

                if (smart) then
                    local is_valid_spawn = false

                    if smart.props and smart.props.territory > 0 and smart.props.base < 1 and smart.props.resource < 1 then
                        if smart.owning_faction == "none" or not game_relations.is_factions_enemies(smart.owning_faction, faction) then
                            is_valid_spawn = true
                        end
                    elseif smart.props and smart.props.resource > 0 and smart.props.base < 1 then
                        if smart.owning_faction == "none" or not game_relations.is_factions_enemies(smart.owning_faction, faction) then
                            is_valid_spawn = true
                        end
                    elseif smart.props and smart.props.lair > 0 and smart.props.base < 1 and smart.props.resource < 1 and smart.props.territory < 1 then
                        is_valid_spawn = true
                    end

                    if is_valid_spawn then
                        local distance = smart_terrain_warfare.fetch_smart_distance(smart, best_target)
                        if distance > 10000 and (best_spawn_dist == nil or distance < best_spawn_dist) then
                            best_spawn_dist = distance
                            best_spawn = smart
                        end
                    end
                end
            end
        end
    end

    if not best_spawn then
        if enable_debug then printf("Emergency resurrection: No valid spawn found for %s targeting %s", faction, best_target:name()) end
        return false
    end

    -- Step 4: Spawn squads at the selected spawn point targeting the selected base
    local emergency_squad_count = math.min(4, math.ceil(best_target.max_population * 1.5))

    if enable_debug then
        printf("Emergency resurrection: spawning %s squads for %s at %s, targeting %s (dist: %s)",
               emergency_squad_count, faction, best_spawn:name(), best_target:name(), best_spawn_dist)
    end

    for j=1,emergency_squad_count do
        local section = faction_expansions.get_spawn_section(faction, faction_information[faction].resource_count)
        local squad = utils_obj.create_squad(section, best_spawn:name())
        if squad then
            sim_squad_warfare.set_target(squad, best_target.id)
        end
    end

    return true
end

-- Helper function to check if a smart terrain is a main faction base
function is_main_faction_base(smart, faction)
    if not smart or not faction or faction == "none" then
        return false
    end

    -- This is a simple heuristic - you may want to customize this
    -- Main bases typically have high max_population and are bases (not resources)
    if smart.props and smart.props.base and smart.props.base > 0 then
        if smart.max_population and smart.max_population >= 8 then
            return true
        end

        -- You can add specific smart terrain name checks here if needed
        local name = smart:name()
        if name then
            -- Add main base names if you know them, e.g.:
            -- if string.find(name, "bar_") or string.find(name, "freedom_base") then
            --     return true
            -- end
        end
    end

    return false
end



-- Helper function to check if a smart terrain is a main base (uses smart_terrain_warfare's function)
function is_smart_main_base(smart_name)
    if not smart_name then
        return false
    end

    -- Use the function from smart_terrain_warfare.script
    if smart_terrain_warfare and smart_terrain_warfare.is_main_base then
        return smart_terrain_warfare.is_main_base(smart_name)
    end

    return false
end

-- Helper function to check if a smart terrain is a main base belonging to a specific faction
function is_faction_main_base(smart_name, faction)
    if not smart_name or not faction then
        return false
    end

    local bases = faction_main_bases[faction]
    if not bases then
        return false
    end

    for _, base_name in pairs(bases) do
        if base_name == smart_name then
            return true
        end
    end

    return false
end
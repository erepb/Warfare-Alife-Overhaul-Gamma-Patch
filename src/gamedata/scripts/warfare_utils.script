function subtract_time(time, secs)
    local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
    Y, M, D, h, m, s, ms = time:get(Y, M, D, h, m, s, ms)

    local day_secs = h * 3600 + m * 60 + s - secs

    while day_secs < 0 do
        D = D - 1
        day_secs = day_secs + 86400
    end

    h = math.floor(day_secs / 3600)
    day_secs = day_secs % 3600
    m = math.floor(day_secs / 60)
    s = day_secs % 60

    local days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
    if Y % 4 == 0 and (Y % 100 ~= 0 or Y % 400 == 0) then
        days_in_month[2] = 29
    end
    while D < 1 do
        M = M - 1
        if M < 1 then
            M = 12
            Y = Y - 1
            if Y % 4 == 0 and (Y % 100 ~= 0 or Y % 400 == 0) then
                days_in_month[2] = 29
            else
                days_in_month[2] = 28
            end
        end
        D = D + days_in_month[M]
    end

    local res = game.get_game_time()
    res:set(Y, M, D, h, m, s, ms)
    return res
end

function add_time(time, secs)
    local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
	Y, M, D, h, m, s, ms = time:get(Y, M, D, h, m, s, ms)
	s = s + secs
	m = m + math.floor(s / 60)
	s = s % 60
	h = h + math.floor(m / 60)
	m = m % 60
	D = D + math.floor(h / 24)
	h = h % 24

	local days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
	if Y % 4 == 0 and (Y % 100 ~= 0 or Y % 400 == 0) then
		days_in_month[2] = 29
	end

	while D > days_in_month[M] do
		D = D - days_in_month[M]
		M = M + 1
		if M > 12 then
			M = 1
			Y = Y + 1
			if Y % 4 == 0 and (Y % 100 ~= 0 or Y % 400 == 0) then
				days_in_month[2] = 29
			else
				days_in_month[2] = 28
			end
		end
	end

    local res = game.get_game_time()
	res:set(Y, M, D, h, m, s, ms)

	return res
end

-- Returns current hour from warfare virtual clock (compatible with gradual time advance)
function get_warfare_hour()
    local h = get_warfare_hms()
    return h
end

-- Returns h, m, s from a CTime object (or warfare virtual clock if none given)
function get_warfare_hms(time_obj)
    local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
    Y, M, D, h, m, s, ms = (time_obj or warfare.get_time_ref()):get(Y, M, D, h, m, s, ms)
    return h, m, s
end

-- Night: 9PM (21:00) to 6AM (05:59)
function is_night()
    local h = get_warfare_hour()
    return h < 6 or h >= 22
end

-- Daylight: 6AM (06:00) to 5PM (16:59)
function is_daylight()
    local h = get_warfare_hour()
    return h >= 6 and h < 17
end

-- Sunset: 5PM (17:00) to 9PM (20:59)
function is_sunset()
    local h = get_warfare_hour()
    return h >= 17 and h < 22
end

-- Not night (daylight or sunset): 6AM (06:00) to 9PM (20:59)
function is_not_night()
    return not is_night()
end

-- Night boundaries in seconds from midnight
local NIGHT_START = 22 * 3600  -- 22:00
local DAWN        =  6 * 3600  -- 06:00
local NIGHT_LEN   =  8 * 3600  -- 28800s (22:00-06:00)
local DAY_LEN     = 16 * 3600  -- 57600s (06:00-22:00)
local FULL_DAY    = 24 * 3600  -- 86400s

-- Compute how many seconds in a time interval fall within night hours (22:00-06:00).
-- start_time: CTime object for interval start; delta: interval length in game seconds.
function compute_night_seconds(start_time, delta)
    if delta <= 0 then return 0 end
    local h, m, s = get_warfare_hms(start_time)
    local total_night = 0
    local pos = h * 3600 + m * 60 + s
    local remaining = delta

    while remaining > 0 do
        if pos >= NIGHT_START or pos < DAWN then
            -- In night: count seconds until dawn
            local to_dawn = pos >= NIGHT_START
                and (FULL_DAY - pos + DAWN)
                or  (DAWN - pos)
            local chunk = math.min(remaining, to_dawn)
            total_night = total_night + chunk
            remaining = remaining - chunk
            pos = (pos + chunk) % FULL_DAY
        else
            -- In day: skip ahead to night start
            local to_night = NIGHT_START - pos
            local chunk = math.min(remaining, to_night)
            remaining = remaining - chunk
            pos = (pos + chunk) % FULL_DAY
        end
    end

    return total_night
end

-- Given a spawn timer timestamp and its full interval (already *6 and with delay),
-- return real game-seconds until spawn, projecting through night periods.
-- During night the timer is effectively frozen, so real time includes the skip.
function get_real_seconds_until_spawn(timer, interval)
    local diff = warfare.get_time():diffSec(timer)
    -- Subtract accumulated night so far (timer hasn't been corrected yet)
    if is_night() then
        diff = diff - warfare.night_accumulated
    end
    local effective_remaining = interval - diff
    if effective_remaining <= 0 then return 0 end

    -- Current time of day in seconds
    local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
    Y, M, D, h, m, s, ms = warfare.get_time():get(Y, M, D, h, m, s, ms)
    local now = h * 3600 + m * 60 + s

    local real = 0

    -- If currently night, first skip to dawn
    if h < 6 or h >= 22 then
        local to_dawn
        if h >= 22 then
            to_dawn = (24 * 3600 - now) + DAWN
        else
            to_dawn = DAWN - now
        end
        real = real + to_dawn
        now = DAWN
    end

    -- Now at daytime: how many day-seconds left in this day period
    local day_left = NIGHT_START - now
    if effective_remaining <= day_left then
        return real + effective_remaining
    end

    -- Consume rest of this day period, then skip night
    effective_remaining = effective_remaining - day_left
    real = real + day_left + NIGHT_LEN

    -- Full day+night cycles
    while effective_remaining > DAY_LEN do
        effective_remaining = effective_remaining - DAY_LEN
        real = real + DAY_LEN + NIGHT_LEN
    end

    -- Remaining fits within a day period
    return real + effective_remaining
end
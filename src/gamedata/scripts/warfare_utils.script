function add_time(time, secs)
    local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
	Y, M, D, h, m, s, ms = time:get(Y, M, D, h, m, s, ms)
	s = s + secs
	m = m + math.floor(s / 60)
	s = s % 60
	h = h + math.floor(m / 60)
	m = m % 60
	D = D + math.floor(h / 24)
	h = h % 24

	local days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
	if Y % 4 == 0 and (Y % 100 ~= 0 or Y % 400 == 0) then
		days_in_month[2] = 29
	end

	while D > days_in_month[M] do
		D = D - days_in_month[M]
		M = M + 1
		if M > 12 then
			M = 1
			Y = Y + 1
			if Y % 4 == 0 and (Y % 100 ~= 0 or Y % 400 == 0) then
				days_in_month[2] = 29
			else
				days_in_month[2] = 28
			end
		end
	end

    local res = game.get_game_time()
	res:set(Y, M, D, h, m, s, ms)

	return res
end

-- Returns current hour from warfare virtual clock (compatible with gradual time advance)
function get_warfare_hour()
    local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
    Y, M, D, h, m, s, ms = warfare.get_time():get(Y, M, D, h, m, s, ms)
    return h
end

-- Night: 9PM (21:00) to 6AM (05:59)
function is_night()
    local h = get_warfare_hour()
    return h < 6 or h >= 22
end

-- Daylight: 6AM (06:00) to 5PM (16:59)
function is_daylight()
    local h = get_warfare_hour()
    return h >= 6 and h < 17
end

-- Sunset: 5PM (17:00) to 9PM (20:59)
function is_sunset()
    local h = get_warfare_hour()
    return h >= 17 and h < 22
end

-- Not night (daylight or sunset): 6AM (06:00) to 9PM (20:59)
function is_not_night()
    return not is_night()
end

-- Night boundaries in seconds from midnight
local NIGHT_START = 22 * 3600  -- 22:00
local DAWN        =  6 * 3600  -- 06:00
local NIGHT_LEN   =  8 * 3600  -- 28800s (22:00-06:00)
local DAY_LEN     = 16 * 3600  -- 57600s (06:00-22:00)

-- Given a spawn timer timestamp and its full interval (already *6 and with delay),
-- return real game-seconds until spawn, projecting through night periods.
-- During night the timer is effectively frozen, so real time includes the skip.
function get_real_seconds_until_spawn(timer, interval)
    local diff = warfare.get_time():diffSec(timer)
    -- Subtract accumulated night so far (timer hasn't been corrected yet)
    if is_night() then
        diff = diff - warfare.night_accumulated
    end
    local effective_remaining = interval - diff
    if effective_remaining <= 0 then return 0 end

    -- Current time of day in seconds
    local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
    Y, M, D, h, m, s, ms = warfare.get_time():get(Y, M, D, h, m, s, ms)
    local now = h * 3600 + m * 60 + s

    local real = 0

    -- If currently night, first skip to dawn
    if h < 6 or h >= 22 then
        local to_dawn
        if h >= 22 then
            to_dawn = (24 * 3600 - now) + DAWN
        else
            to_dawn = DAWN - now
        end
        real = real + to_dawn
        now = DAWN
    end

    -- Now at daytime: how many day-seconds left in this day period
    local day_left = NIGHT_START - now
    if effective_remaining <= day_left then
        return real + effective_remaining
    end

    -- Consume rest of this day period, then skip night
    effective_remaining = effective_remaining - day_left
    real = real + day_left + NIGHT_LEN

    -- Full day+night cycles
    while effective_remaining > DAY_LEN do
        effective_remaining = effective_remaining - DAY_LEN
        real = real + DAY_LEN + NIGHT_LEN
    end

    -- Remaining fits within a day period
    return real + effective_remaining
end
--[[

=======================================================================================
	Original creator: Werejew
	Edit log:
	2020/11/07 - Vintar - Resurgence chance added to resurgence calculation
	2021/02/19 - Vintar - stronger resurgence attempts, now uses fetch_smart_distance(), debug messages
	2021/03/27 - Vintar - loners exempt from random patrol targeting. Random patrols no longer spawn too close to actor.
	2021/11/22 - Vintar - slight change to resurgence base count

	This file handles faction-level warfare stuff like random patrols, resurgences, etc.
=======================================================================================

--]]


printd = warfare.printd

factions_p = {}
factions = {
    "stalker",
    "bandit",
    "csky",
    "army",
    "freedom",
    "dolg",
    "ecolog",
    "killer",
    "monolith",
    "greh",
    "renegade",
    "isg",
    --"monster",
    "zombied",
}

all_factions = {
    "stalker",
    "bandit",
    "csky",
    "army",
    "freedom",
    "dolg",
    "ecolog",
    "killer",
    "monolith",
    "greh",
    "renegade",
    "isg",
    "monster",
    "zombied",
}

faction_information = {}
faction_timers = {}

for i=1,#factions do
    factions_p[factions[i]] = true
end

--[[

	faction_information[faction] = {
		base_count,
		resource_count,
		total_power,
		defense_squads, -- current_action == 1 and (target.props.base > 0 or target.props.resource > 0)
		offense_squads, -- current_action == 0 and (target.props.base > 0 or target.props.resource > 0)
		patrol_squads,	-- current_action == 0 and (target.props.base == 0 and target.props.resource == 0)
		relations = {
			[faction] = value
		},
	}

]]

function update()
    for i,faction in pairs(factions) do
        if faction ~= "monster" then
            update_faction(faction)
        end
    end
end

function update_faction(faction)
    if (not faction or faction == "none") then
        return
    end

    if not (faction_information[faction]) then
        local min_resurgence_wait_time = warfare_options.options.factions[faction].min_resurgence_wait_time
        local max_resurgence_wait_time = warfare_options.options.factions[faction].max_resurgence_wait_time
        local faction_resurgence_chance = warfare_options.options.factions[faction].resurgence_chance

        local max_random_patrols = warfare_options.options.factions[faction].max_random_patrols
        local min_random_patrol_time = warfare_options.options.factions[faction].min_random_patrol_time
        local max_random_patrol_time = warfare_options.options.factions[faction].max_random_patrol_time

        local next_resurgence_attempt = math.random(min_resurgence_wait_time, max_resurgence_wait_time)
        local next_random_patrol = math.random(min_random_patrol_time, max_random_patrol_time)

        faction_information[faction] = {}
        faction_information[faction].base_count = 0
        faction_information[faction].resource_count = 0
        faction_information[faction].total_power = 0
        faction_information[faction].inactive_squads = 0
        faction_information[faction].active_squads = 0
        faction_information[faction].faction_respawn = 0
        faction_information[faction].patrol_respawn = 0
        faction_information[faction].patrol_squads = 0
        faction_information[faction].invasion_size = 0
        faction_information[faction].patrol_pop_factor = 0
        faction_information[faction].last_resurgence_attempt = game.get_game_time()
        faction_information[faction].next_resurgence_attempt = next_resurgence_attempt
        faction_information[faction].next_random_patrol = 0
        faction_information[faction].last_random_patrol = game.get_game_time()
    end

    if (not faction_information[faction].timer or game.get_game_time():diffSec(faction_information[faction].timer) >= (faction_information[faction].next_update*6)) then
        printd(0, faction or "nil faction")

        local min_resurgence_wait_time = warfare_options.options.factions[faction].min_resurgence_wait_time
        local max_resurgence_wait_time = warfare_options.options.factions[faction].max_resurgence_wait_time
        local faction_resurgence_chance = warfare_options.options.factions[faction].resurgence_chance

        local max_random_patrols = warfare_options.options.factions[faction].max_random_patrols
        local min_random_patrol_time = warfare_options.options.factions[faction].min_random_patrol_time
        local max_random_patrol_time = warfare_options.options.factions[faction].max_random_patrol_time

        local last_resurgence_attempt = faction_information[faction].last_resurgence_attempt or game.get_game_time()
        local next_resurgence_attempt = faction_information[faction].next_resurgence_attempt or math.random(min_resurgence_wait_time, max_resurgence_wait_time)
        local last_random_patrol = faction_information[faction].last_random_patrol or game.get_game_time()
        local next_random_patrol = faction_information[faction].next_random_patrol or math.random(min_random_patrol_time, max_random_patrol_time)

        faction_information[faction] = {}
        faction_information[faction].timer = game.get_game_time()
        faction_information[faction].next_update = math.random(1, 5)
        faction_information[faction].base_count = 0
        faction_information[faction].resource_count = 0
        faction_information[faction].total_power = 0
        faction_information[faction].inactive_squads = 0
        faction_information[faction].active_squads = 0
        faction_information[faction].faction_respawn = 0
        faction_information[faction].patrol_respawn = 0
        faction_information[faction].patrol_squads = 0
        faction_information[faction].invasion_size = 0
        faction_information[faction].patrol_pop_factor = 0
        faction_information[faction].last_resurgence_attempt = last_resurgence_attempt
        faction_information[faction].next_resurgence_attempt = next_resurgence_attempt
        faction_information[faction].last_random_patrol = last_random_patrol
        faction_information[faction].next_random_patrol = next_random_patrol

        for i,lvl in pairs(level_targets.active_levels) do
            local info = warfare_levels.level_information[lvl]

            if (info.faction_stats and info.faction_stats[faction]) then
                local num_active = sim_offline_combat.get_num_squads_on_level(lvl, faction, true)
                local num_inactive = sim_offline_combat.get_num_squads_on_level(lvl, faction, false)

                faction_information[faction].base_count = faction_information[faction].base_count + info.faction_stats[faction].base_count
                faction_information[faction].resource_count = faction_information[faction].resource_count + info.faction_stats[faction].resource_count
                faction_information[faction].total_power = faction_information[faction].total_power + info.faction_stats[faction].total_power
                faction_information[faction].active_squads = faction_information[faction].active_squads + num_active
                faction_information[faction].inactive_squads = faction_information[faction].inactive_squads + num_inactive
            end
        end

        local ff = warfare_options.options.factions[faction]

        if not (ff) then
            return
        end

        local base_count = faction_information[faction].base_count or 0
        local resource_count = faction_information[faction].resource_count or 0

        if (game_relations.is_factions_enemies(faction, warfare.actor_faction)) then
            base_count = base_count + warfare_options.options.enemy_base_boost
            resource_count = resource_count + warfare_options.options.enemy_resource_boost
        end

        base_count = base_count + (ff and ff.base_count_modifier or 0)
        resource_count = resource_count + (ff and ff.resource_count_modifier or 0)

        faction_information[faction].base_count = base_count
        faction_information[faction].resource_count = resource_count

        local respawn = warfare.lerp(ff.max_faction_respawn, ff.min_faction_respawn, clamp(resource_count / warfare.resource_count, 0, 1))
        local patrol_respawn = warfare.lerp(ff.max_patrol_time, ff.min_patrol_time, clamp(resource_count / warfare.resource_count, 0, 1))
        local invasion_size = warfare.lerp(ff.min_invasion_size, ff.max_invasion_size, clamp(base_count / warfare.base_count, 0, 1))
        local patrol_pop_factor = warfare.lerp(ff.min_patrol_squads, ff.max_patrol_squads, clamp(base_count / warfare.base_count, 0, 1))

        for faction,tbl in pairs(warfare.registered_squads) do
            for ID,target in pairs(tbl) do
                local obj = alife_object(ID)

                if (obj) then
                    if not (obj.clsid and obj:clsid() == clsid.online_offline_group_s and obj:get_squad_community() == faction) then
                        warfare.registered_squads[faction][ID] = nil
                    end
                else
                    warfare.registered_squads[faction][ID] = nil
                end
            end
        end

        faction_information[faction].faction_respawn = respawn
        faction_information[faction].patrol_respawn = patrol_respawn
        faction_information[faction].patrol_squads = patrol_squads
        faction_information[faction].invasion_size = invasion_size
        faction_information[faction].patrol_pop_factor = patrol_pop_factor

        local mod = (ff and ff.base_count_modifier or 0)

        if (game_relations.is_factions_enemies(faction, warfare.actor_faction)) then
            mod = mod + warfare_options.options.enemy_base_boost
        end

        if (warfare_options.options.factions[faction].random_patrols) then
            if (game.get_game_time():diffSec(faction_information[faction].last_random_patrol) > faction_information[faction].next_random_patrol*6) then
                faction_information[faction].last_random_patrol = game.get_game_time()
                faction_information[faction].next_random_patrol = math.random(min_random_patrol_time, max_random_patrol_time)

                local start_id = smart_terrain_warfare.find_random_patrol_target(nil, faction)
                local start = start_id and alife_object(start_id)
                local target_id

                -- loners/ecolog don't get sent off randomly, they get sent according to their respective loner/ecolog process functions
                if (faction == "stalker") or (faction == "ecolog") then
                    target_id = start_id
                else
                    target_id = smart_terrain_warfare.find_random_patrol_target(start, faction)
                end

                local count = 0
                for squad_id, squad_faction in pairs(smart_terrain_warfare.random_patrols) do
                    if (squad_faction and squad_faction == faction) then
                        count = count + 1
                    end
                end

                if (start and target_id and (count < max_random_patrols)) then
                    local spawn_random_patrol = true

                    -- don't spawn random patrols too close to player
                    if (start.is_on_actor_level) then
                        local actor_dist = start.position:distance_to(db.actor:position())
                        if (actor_dist < 50) then
                            spawn_random_patrol = false
                            faction_information[faction].next_random_patrol = math.random(30,120)		-- if random patrol fails to spawn, check back sooner to try elsewhere
                        end
                    end

                    if spawn_random_patrol then
                        local section = faction_expansions.get_spawn_section(faction, faction_information[faction].resource_count)
                        local squad = utils_obj.create_squad(section, start:name())
                        smart_terrain_warfare.random_patrols[squad.id] = faction
                        sim_squad_warfare.set_target(squad, target_id)
                    end
                end
            end
        end

        -- Emergency resurrection when faction has 0 bases
        if (warfare_options.options.factions[faction].participate_in_warfare and (faction_information[faction].base_count + mod) < 1) then
            if (game.get_game_time():diffSec(faction_information[faction].last_resurgence_attempt) > faction_information[faction].next_resurgence_attempt*6) then
                faction_information[faction].last_resurgence_attempt = game.get_game_time()
                faction_information[faction].next_resurgence_attempt = math.random(min_resurgence_wait_time, max_resurgence_wait_time)

                -- Choose between new and old resurgence logic
                if warfare_options.options.use_new_resurgence_logic then
                    -- Emergency spawn: Create powerful squad for extinct factions
                    local emergency_attempted = emergency_resurrection_spawn(faction)
                    if emergency_attempted then
                        if (smart_terrain_warfare.enable_debug) then
                            printf("Emergency resurrection activated for extinct faction: %s", faction)
                        end
                    end
                else
                    -- Original resurgence logic with chance to skip
                    if math.random(0,99) < faction_resurgence_chance then
                        local levels = warfare.hash_table_to_array(level_targets.active_levels)
                        warfare.shuffleTable(levels)

                        local attempted = false
                        for _,v in pairs(levels) do
                            local chosen = v.key
                            local info = warfare_levels.level_information[chosen]

                            if (info) then
                                local smarts = info.smarts
                                local targets = {}
                                local spawns = {}

                                for v,smart_id in pairs(smarts) do
                                    local smart = alife_object(smart_id)

                                    if (smart) then
                                        if (smart.props and smart.props.base > 0) then
                                            if (smart.owning_faction == "none" or game_relations.is_factions_enemies(smart.owning_faction, faction)) then
                                                targets[#targets+1] = smart
                                            end
                                        elseif (smart.props and smart.props.territory > 0 and (smart.props.resource == nil or smart.props.resource <= 0)) then
                                            spawns[#spawns+1] = smart
                                        end
                                    end
                                end

                                if (#spawns > 0 and #targets > 0) then
                                    local target = targets[math.random(#targets)]

                                    -- stronger resurgence attempts
                                    local target_pop = 2 * target.max_population

                                    local nearest_smart = nil
                                    local nearest_dist = nil

                                    attempted = true

                                    if (smart_terrain_warfare.enable_debug) then
                                        printf("Resurgence of %s is underway, targeting %s with %s squads", faction, target:name(), target_pop)
                                    end

                                    for _,ter in pairs(spawns) do
                                        local d = smart_terrain_warfare.fetch_smart_distance(target, ter)

                                        if (nearest_dist == nil or d < nearest_dist) then
                                            nearest_smart = ter
                                            nearest_dist = d
                                        end
                                    end

                                    for j=0,target_pop do
                                        local section = faction_expansions.get_spawn_section(faction, faction_information[faction].resource_count)
                                        local squad = utils_obj.create_squad(section, nearest_smart:name())
                                        sim_squad_warfare.set_target(squad, target.id)
                                    end
                                end
                            end

                            if (attempted) then
                                break
                            end
                        end
                    end
                end
            end
        end

        printd(9, "true end")
    end
end

-- Emergency resurrection function for extinct factions
function emergency_resurrection_spawn(faction)
    if not faction or faction == "none" then
        return false
    end

    local levels = warfare.hash_table_to_array(level_targets.active_levels)
    warfare.shuffleTable(levels)

    local all_targets = {}
    local priority_targets = {} -- Former faction bases get priority
    local all_spawns = {}

    -- Collect all possible targets and spawn points across all levels
    for _,v in pairs(levels) do
        local chosen = v.key
        local info = warfare_levels.level_information[chosen]

        if (info) then
            local smarts = info.smarts

            for v,smart_id in pairs(smarts) do
                local smart = alife_object(smart_id)

                if (smart) then
                    -- Target: enemy or empty bases
                    if (smart.props and smart.props.base > 0 ) then
                        if (smart.owning_faction == "none" or game_relations.is_factions_enemies(smart.owning_faction, faction)) then
                            local is_main_base = is_smart_main_base(smart:name())

                            if is_main_base then
                                -- Only prioritize THIS faction's main bases for reclaiming
                                if is_faction_main_base(smart:name(), faction) then
                                    priority_targets[#priority_targets+1] = smart
                                    if (smart_terrain_warfare.enable_debug) then
                                        printf("Emergency resurrection: Found %s main base target %s for reclaiming", faction, smart:name())
                                    end
                                end
                                -- Other factions' main bases are excluded from targeting completely
                                -- (no else clause - they don't get added to any target list)
                            else
                                -- Regular bases and resources are fair game
                                all_targets[#all_targets+1] = smart
                            end
                        end
                    -- Spawn point: neutral territories or any owned territory
                    elseif (smart.props and smart.props.territory > 0) then
                        all_spawns[#all_spawns+1] = smart
                    end
                end
            end
        end
    end

    if (#all_spawns > 0 and (#priority_targets > 0 or #all_targets > 0)) then
        -- Find closest target to any spawn point, prioritizing former faction bases
        local best_target = nil
        local best_spawn = nil
        local best_distance = nil

        -- First, try to target former faction bases (priority targets)
        if (#priority_targets > 0) then
            for _,spawn in pairs(all_spawns) do
                for _,target in pairs(priority_targets) do
                    local distance = smart_terrain_warfare.fetch_smart_distance(spawn, target)
                    if (best_distance == nil or distance < best_distance) then
                        best_distance = distance
                        best_target = target
                        best_spawn = spawn
                    end
                end
            end

            if (smart_terrain_warfare.enable_debug and best_target) then
                printf("Emergency resurrection: Targeting priority main base %s for faction %s", best_target:name(), faction)
            end
        end

        -- If no priority targets found or accessible, fall back to regular targets
        if (not best_target and #all_targets > 0) then
            for _,spawn in pairs(all_spawns) do
                for _,target in pairs(all_targets) do
                    local distance = smart_terrain_warfare.fetch_smart_distance(spawn, target)
                    if (best_distance == nil or distance < best_distance) then
                        best_distance = distance
                        best_target = target
                        best_spawn = spawn
                    end
                end
            end

            if (smart_terrain_warfare.enable_debug and best_target) then
                printf("Emergency resurrection: Targeting fallback target %s for faction %s", best_target:name(), faction)
            end
        end

        if (best_target and best_spawn) then
            -- Create a powerful emergency squad (3x normal max population)
            local emergency_squad_count = math.max(3, best_target.max_population * 3)

            if (smart_terrain_warfare.enable_debug) then
                printf("Emergency resurrection: spawning %s squads for %s at %s, targeting %s",
                       emergency_squad_count, faction, best_spawn:name(), best_target:name())
            end

            for j=1,emergency_squad_count do
                local section = faction_expansions.get_spawn_section(faction, faction_information[faction].resource_count)
                local squad = utils_obj.create_squad(section, best_spawn:name())
                if squad then
                    sim_squad_warfare.set_target(squad, best_target.id)
                end
            end

            return true
        end
    end

    return false
end

-- Helper function to check if a smart terrain is a main faction base
function is_main_faction_base(smart, faction)
    if not smart or not faction or faction == "none" then
        return false
    end

    -- This is a simple heuristic - you may want to customize this
    -- Main bases typically have high max_population and are bases (not resources)
    if smart.props and smart.props.base and smart.props.base > 0 then
        if smart.max_population and smart.max_population >= 8 then
            return true
        end

        -- You can add specific smart terrain name checks here if needed
        local name = smart:name()
        if name then
            -- Add main base names if you know them, e.g.:
            -- if string.find(name, "bar_") or string.find(name, "freedom_base") then
            --     return true
            -- end
        end
    end

    return false
end

-- Mapping of main bases to their original factions
local faction_main_bases = {
    ["dolg"] = {"bar_dolg_general", "bar_dolg_bunker", "bar_zastava", "bar_zastava_2"},
    ["freedom"] = {"mil_smart_terrain_7_7", "mil_smart_terrain_7_8", "mil_smart_terrain_7_10", "mil_smart_terrain_7_12"},
    ["army"] = {"agr_smart_terrain_1_6", "agr_smart_terrain_1_6_near_1", "agr_smart_terrain_1_6_near_2"},
    ["bandit"] = {"val_smart_terrain_7_3", "val_smart_terrain_7_4", "val_smart_terrain_7_5"},
    ["killer"] = {"cit_killers"},
    ["monolith"] = {"pri_monolith", "pri_a18_smart_terrain"},
    ["ecolog"] = {"yan_smart_terrain_6_4", "jup_b41"},
    ["csky"] = {"mar_smart_terrain_base"},
    ["stalker"] = {"esc_smart_terrain_2_12", "jup_a6", "zat_stalker_base_smart"},
    ["renegade"] = {"red_smart_terrain_3_2"},
    -- pri_a16 (Stranded Mercenaries) - unclear faction, treating as neutral
}

-- Helper function to check if a smart terrain is a main base (uses smart_terrain_warfare's function)
function is_smart_main_base(smart_name)
    if not smart_name then
        return false
    end

    -- Use the function from smart_terrain_warfare.script
    if smart_terrain_warfare and smart_terrain_warfare.is_main_base then
        return smart_terrain_warfare.is_main_base(smart_name)
    end

    return false
end

-- Helper function to check if a smart terrain is a main base belonging to a specific faction
function is_faction_main_base(smart_name, faction)
    if not smart_name or not faction then
        return false
    end

    local bases = faction_main_bases[faction]
    if not bases then
        return false
    end

    for _, base_name in pairs(bases) do
        if base_name == smart_name then
            return true
        end
    end

    return false
end